var documenterSearchIndex = {"docs":
[{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/","page":"API","title":"API","text":"Modules = [EPGsim]","category":"page"},{"location":"API/#EPGsim.epgDephasing","page":"API","title":"EPGsim.epgDephasing","text":"epgDephasing(E::EPGStates, n=1) where T\n\nshifts the transverse dephasing states F corresponding to n dephasing-cycles.\n\n\n\n\n\n","category":"function"},{"location":"API/#EPGsim.epgRelaxation-Tuple{EPGStates, Any, Any, Any}","page":"API","title":"EPGsim.epgRelaxation","text":"epgRelaxation(E::EPGStates,t,T1, T2)\n\napplies relaxation matrices to a set of EPG states.\n\nArguments\n\nE::EPGStates\nt::AbstractFloat    - length of time interval\nT1::AbstractFloat   - T1\nT2::AbstractFloat   - T2\n\n\n\n\n\n","category":"method"},{"location":"API/#EPGsim.epgRotation","page":"API","title":"EPGsim.epgRotation","text":"epgRotation(E::EPGStates, alpha::Float64, phi::Float64=0.0)\n\napplies Bloch-rotation (<=> RF pulse) to a set of EPG states.\n\nArguments\n\nE::EPGStates`\nalpha::Float64           - flip angle of the RF pulse\nphi::Float64=0.0         - phase of the RF pulse\n\n\n\n\n\n","category":"function"},{"location":"API/#EPGsim.rfRotation","page":"API","title":"EPGsim.rfRotation","text":"rfRotation_AT(alpha, phi=0.)\n\nreturns the rotation matrix for a pulse with flip angle alpha and phase phi.\n\n\n\n\n\n","category":"function"},{"location":"regular/","page":"Regular EPG ","title":"Regular EPG ","text":"EPG implementation that mimics the regular implementation from Julien Lamy in Sycomore","category":"page"},{"location":"regular/#Short-description","page":"Regular EPG ","title":"Short description","text":"","category":"section"},{"location":"regular/","page":"Regular EPG ","title":"Regular EPG ","text":"We use F+, F- and Z to store the states","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"EditURL = \"https://github.com/aTrotier/EPGsim.jl/blob/main/docs/lit/01-autoDiff.jl\"","category":"page"},{"location":"generated/01-autoDiff/#autoDiff","page":"Test literate","title":"Automatic Differentiation","text":"","category":"section"},{"location":"generated/01-autoDiff/#Description","page":"Test literate","title":"Description","text":"","category":"section"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"This example described how to use Automatic Differentiation with the package ForwardDiff.jl on a Multi-Echo Spin-Echo (MESE) sequence.","category":"page"},{"location":"generated/01-autoDiff/#Setup","page":"Test literate","title":"Setup","text":"","category":"section"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"using CairoMakie\nusing EPGsim\nusing ForwardDiff","category":"page"},{"location":"generated/01-autoDiff/#MESE-function","page":"Test literate","title":"MESE function","text":"","category":"section"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"First we need a function that returns the echo amplitudes at n*TE. We need to make sure that the EPGStates object will have a type Complex{T} where T can be a Float or a Dual number used by ForwardDiff","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"function MESE_EPG(T2,T1,TE,ETL,delta)\n    T = complex(eltype(T2))\n    E = EPGStates([T(0.0)],[T(0.0)],[T(1.0)])\n    echo_vec = Vector{Complex{eltype(T2)}}()\n\n    E = epgRotation(E,pi/2*delta, pi/2)\n    ##loop over refocusing-pulses\n    for i = 1:ETL\n      E = epgDephasing(E,1)\n      E = epgRelaxation(E,TE,T1,T2)\n      E  = epgRotation(E,pi*delta,0.0)\n      E  = epgDephasing(E,1)\n      push!(echo_vec,E.Fp[1])\n    end\n\n    return abs.(echo_vec)\n  end","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"Let's see if we can see a T₂ decaying exponential curve with B₁=1.0","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"T2 = 60.0\nT1 = 1000.0\nTE = 7\nETL = 50\ndeltaB1 = 1\nTE_vec = range(7,50*7,50)\n\namp = MESE_EPG(T2,T1,TE,ETL,deltaB1)\nj = ForwardDiff.jacobian(x -> MESE_EPG(x,T1,TE,ETL,deltaB1),[60.0])\nlines(TE_vec,amp)","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"The derivative of the function f: f(x) = exp(-fracTET_2) according to the variable T₂ gives :","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"df = TE_vec .* exp.(-TE_vec./T2)./(T2^2)\n\nlines(TE_vec,df,axis =(;title = \"dS/dT2\", xlabel=\"TE [ms]\"))","category":"page"},{"location":"generated/01-autoDiff/#perform-AD","page":"Test literate","title":"perform AD","text":"","category":"section"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"j = ForwardDiff.jacobian(x -> MESE_EPG(x,T1,TE,ETL,deltaB1),[T2])","category":"page"},{"location":"generated/01-autoDiff/#Reproducibility","page":"Test literate","title":"Reproducibility","text":"","category":"section"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"using InteractiveUtils\nio = IOBuffer();\nversioninfo(io);\nsplit(String(take!(io)), '\\n')","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"And with the following package versions","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"","category":"page"},{"location":"generated/01-autoDiff/","page":"Test literate","title":"Test literate","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EPGsim","category":"page"},{"location":"#EPGsim","page":"Home","title":"EPGsim","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for EPGsim.","category":"page"},{"location":"AD/#Automatic-differentiation","page":"Automatic Differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"This page shows how to use Automatic Differentiation in combination with an EPG simulation. ","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"The AD package tested is ForwardDiff.jl, maybe it works with others with some minor modification to the following code.","category":"page"},{"location":"AD/#Load-package","page":"Automatic Differentiation","title":"Load package","text":"","category":"section"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"using EPGsim, ForwardDiff, CairoMakie","category":"page"},{"location":"AD/#Building-signal-function","page":"Automatic Differentiation","title":"Building signal function","text":"","category":"section"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"function MESE_EPG(T2,T1,TE,ETL,delta)\n  T = eltype(complex(T2))\n  E = EPGStates([T(0.0)],[T(0.0)],[T(1.0)])\n  echo_vec = Vector{Complex{eltype(T2)}}()\n\n  E = epgRotation(E,pi/2*delta, pi/2)\n  # loop over refocusing-pulses\n  for i = 1:ETL\n    E = epgDephasing(E,1)\n    E = epgRelaxation(E,TE,T1,T2)\n    E  = epgRotation(E,pi*delta,0.0)\n    E  = epgDephasing(E,1)\n    push!(echo_vec,E.Fp[1])\n  end\n\n  return abs.(echo_vec)\nend;","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"warning: Specific types with AD\nForwardDiff use a specific type : Dual <: Real. The target function must be written generically enough to accept numbers of type T<:Real as input (or arrays of these numbers).We also need to create an EPGStates that is of that type. We need to force it to be complex :T = eltype(complex(T2))\nE = EPGStates([T(0.0)],[T(0.0)],[T(1.0)])","category":"page"},{"location":"AD/#Define-parameters-for-simulation-and-run-it","page":"Automatic Differentiation","title":"Define parameters for simulation and run it","text":"","category":"section"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"T2 = 60.0\nT1 = 1000.0\nTE = 7\nETL = 50\ndeltaB1 = 1\n\nTE_vec = range(TE,TE*ETL,ETL)\n\namp = MESE_EPG(T2,T1,TE,ETL,deltaB1)\nlines(TE_vec,abs.(amp),axis =(;title = \"MESE Signal\", xlabel=\"TE [ms]\"))","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"As expected, we get a standard T2 decaying exponential curve :","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"S(TE) = exp(-TET_2)","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"We can analytically derive the equation according to T_2 :","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"fracpartial Spartial T_2 = fracTET_2^2 exp(-TET_2)","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"which give the following curves:","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"df = TE_vec .* exp.(-TE_vec./T2)./(T2^2) \n\nlines(TE_vec,abs.(df),axis =(;title = \"dS/dT2\", xlabel=\"TE [ms]\"))","category":"page"},{"location":"AD/#Find-the-derivative-with-Automatic-Differentiation","page":"Automatic Differentiation","title":"Find the derivative with Automatic Differentiation","text":"","category":"section"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Because we want to obtain the derivate at multiple time points (TE), we will use ForwardDiff.jacobian :","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"j = ForwardDiff.jacobian(x -> MESE_EPG(x,T1,TE,ETL,deltaB1),[T2])","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Let's compare it to the analytical equation :","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"f=Figure()\nax = Axis(f[1,1],title =\"Analytic vs Automatic Differentiation\")\n\nlines!(ax,TE_vec,abs.(df),label = \"Analytic Differentiation\",linewidth=3)\nlines!(ax,TE_vec,abs.(vec(j)),label = \"Automatic Differentiation\",linestyle=:dash,linewidth=3)\naxislegend(ax)\nf","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Of course, in that case we don't really need the AD possibility. But if we reduce the B1+ value the equation becomes complicated enough and might lead to error during derivation if we don't use AD.","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"deltaB1 = 0.8\n\namp = MESE_EPG(T2,T1,TE,ETL,deltaB1)\nj = ForwardDiff.jacobian(x -> MESE_EPG(x,T1,TE,ETL,deltaB1),[T2])\n\nf = Figure()\nax = Axis(f[1,1], title = \"MESE signal with B1 = $(deltaB1)\",xlabel=\"TE [ms]\")\nlines!(ax,TE_vec,abs.(amp))\nax = Axis(f[1,2], title = \"AD of MESE signal with B1 = $(deltaB1)\",xlabel=\"TE [ms]\")\nlines!(ax,TE_vec,df)\nf","category":"page"},{"location":"AD/#Reproducibility","page":"Automatic Differentiation","title":"Reproducibility","text":"","category":"section"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"using InteractiveUtils\nio = IOBuffer();\nversioninfo(io);\nsplit(String(take!(io)), '\\n')","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"And with the following package versions","category":"page"},{"location":"AD/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"import Pkg; Pkg.status()","category":"page"}]
}
